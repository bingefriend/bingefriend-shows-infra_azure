# This workflow will build a Python app using Poetry, generate requirements.txt,
# and deploy it to an Azure Functions App on Linux when a new release is published.
#
# This workflow assumes you have already created the target Azure Functions app.
# For instructions see https://learn.microsoft.com/en-us/azure/azure-functions/create-first-function-vs-code-python?pivots=python-mode-configuration
#
# To configure this workflow:
# 1. Set up the following secrets in your repository:
#    - AZURE_FUNCTIONAPP_PUBLISH_PROFILE
# 2. Ensure your pyproject.toml file is correctly configured for your project.
# 3. Change env variables for your configuration.
#
# For more information on:
#    - GitHub Actions for Azure: https://github.com/Azure/Actions
#    - Azure Functions Action: https://github.com/Azure/functions-action
#    - Publish Profile: https://github.com/Azure/functions-action#using-publish-profile-as-deployment-credential-recommended
#    - Azure Service Principal for RBAC: https://github.com/Azure/functions-action#using-azure-service-principal-for-rbac-as-deployment-credential
#
# For more samples to get started with GitHub Action workflows to deploy to Azure: https://github.com/Azure/actions-workflow-samples/tree/master/FunctionApp

name: Deploy Python project to Azure Function App on Release

# Trigger the workflow when a new release is published
on:
  release:
    types: [published]

env:
  AZURE_FUNCTIONAPP_NAME: 'tvbingefriendshows'    # set this to your function app name on Azure
  AZURE_FUNCTIONAPP_PACKAGE_PATH: '.'        # set this to the path to your function app project (where pyproject.toml is located)
  PYTHON_VERSION: '3.11'                      # set this to the python version to use

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    environment: prod # Or your target environment
    steps:
    - name: 'Checkout GitHub Action'
      uses: actions/checkout@v4

    # If you want to use Azure RBAC instead of Publish Profile, then uncomment the task below
    # - name: 'Login via Azure CLI'
    #   uses: azure/login@v1
    #   with:
    #     creds: ${{ secrets.AZURE_RBAC_CREDENTIALS }} # set up AZURE_RBAC_CREDENTIALS secrets in your repository

    - name: Setup Python ${{ env.PYTHON_VERSION }} Environment
      uses: actions/setup-python@v4
      with:
        python-version: ${{ env.PYTHON_VERSION }}

    - name: Install Poetry and poetry-plugin-export
      run: |
        python -m pip install --upgrade pip
        pip install poetry
        poetry --version # Output poetry version for debugging
        poetry plugin add poetry-plugin-export # For Poetry 1.2+ to enable 'poetry export'

    - name: Generate requirements.txt and Install Dependencies
      shell: bash
      run: |
        # Navigate to the Azure Function App package path.
        # This is where pyproject.toml and poetry.lock should be located.
        pushd './${{ env.AZURE_FUNCTIONAPP_PACKAGE_PATH }}'
        
        echo "Current directory: $(pwd)"
        echo "Listing files before poetry export:"
        ls -la

        # Generate requirements.txt from pyproject.toml using poetry export.
        # --without-hashes is often recommended for Azure Functions.
        # --without dev (or --only main) ensures dev dependencies are not included.
        echo "Generating requirements.txt using Poetry..."
        poetry export -f requirements.txt --output requirements.txt --without-hashes --without dev
        
        # Verify that requirements.txt was created
        if [ ! -f requirements.txt ]; then
          echo "ERROR: requirements.txt not found after poetry export!"
          echo "Listing files in current directory:"
          ls -la
          exit 1
        fi
        echo "Successfully generated requirements.txt:"
        cat requirements.txt

        # Install application dependencies into the .python_packages directory,
        # which is the standard location Azure Functions expects.
        echo "Installing dependencies using pip from generated requirements.txt..."
        python -m pip install --upgrade pip
        pip install -r requirements.txt --target=".python_packages/lib/python${{ env.PYTHON_VERSION }}/site-packages"
        
        echo "Listing contents of .python_packages:"
        ls -R .python_packages
        
        # Navigate back to the original directory
        popd

    - name: 'Run Azure Functions Action'
      uses: Azure/functions-action@v1
      id: fa
      with:
        app-name: ${{ env.AZURE_FUNCTIONAPP_NAME }}
        package: ${{ env.AZURE_FUNCTIONAPP_PACKAGE_PATH }} # This should point to the directory with host.json, function_app.py etc.
        publish-profile: ${{ secrets.AZURE_FUNCTIONAPP_PUBLISH_PROFILE }} # Remove publish-profile to use Azure RBAC
        # scm-do-build-during-deployment: true # Default is false. Set to true if Oryx build is desired on Azure.
                                              # If false, it expects all dependencies to be in .python_packages.
                                              # Given we are populating .python_packages, false might be more direct.
                                              # However, true can be a fallback if local packaging is incomplete.
                                              # Let's keep it true for robustness, or set to false if you are confident
                                              # about the .python_packages content.
        scm-do-build-during-deployment: true
        enable-oryx-build: true # This works with scm-do-build-during-deployment=true
        # If you set scm-do-build-during-deployment to false, you might not need enable-oryx-build or set it to false.
